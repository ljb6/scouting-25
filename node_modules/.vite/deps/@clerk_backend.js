import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-HFZ37CMS.js";

// node_modules/@clerk/backend/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/@clerk/backend/node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports, module) {
    "use strict";
    var isObject = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module.exports = (object, mapper, options) => {
      if (!isObject(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/tslib/tslib.es6.js
var __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/lower-case/dist.es2015/index.js
function lowerCase(str) {
  return str.toLowerCase();
}
var init_dist = __esm({
  "node_modules/lower-case/dist.es2015/index.js"() {
  }
});

// node_modules/no-case/dist.es2015/index.js
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
var DEFAULT_SPLIT_REGEXP, DEFAULT_STRIP_REGEXP;
var init_dist2 = __esm({
  "node_modules/no-case/dist.es2015/index.js"() {
    init_dist();
    DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  }
});

// node_modules/dot-case/dist.es2015/index.js
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
var init_dist3 = __esm({
  "node_modules/dot-case/dist.es2015/index.js"() {
    init_tslib_es6();
    init_dist2();
  }
});

// node_modules/snake-case/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  snakeCase: () => snakeCase
});
function snakeCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "_" }, options));
}
var init_dist4 = __esm({
  "node_modules/snake-case/dist.es2015/index.js"() {
    init_tslib_es6();
    init_dist3();
  }
});

// node_modules/snakecase-keys/index.js
var require_snakecase_keys = __commonJS({
  "node_modules/snakecase-keys/index.js"(exports, module) {
    "use strict";
    var map = require_map_obj();
    var { snakeCase: snakeCase2 } = (init_dist4(), __toCommonJS(dist_exports));
    module.exports = function(obj, options) {
      options = Object.assign({ deep: true, exclude: [], parsingOptions: {} }, options);
      return map(obj, function(key, val) {
        return [
          matches(options.exclude, key) ? key : snakeCase2(key, options.parsingOptions),
          val
        ];
      }, options);
    };
    function matches(patterns, value) {
      return patterns.some(function(pattern) {
        return typeof pattern === "string" ? pattern === value : pattern.test(value);
      });
    }
  }
});

// node_modules/@clerk/backend/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/@clerk/backend/node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse3;
    exports.serialize = serialize;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse3(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode2;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode2(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode3) {
      try {
        return decode3(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/@clerk/shared/dist/chunk-KJVJ4CFF.mjs
var isTestEnvironment = () => {
  try {
    return false;
  } catch (err) {
  }
  return false;
};
var isProductionEnvironment = () => {
  try {
    return false;
  } catch (err) {
  }
  return false;
};
var displayedWarnings = /* @__PURE__ */ new Set();
var deprecated = (fnName, warning, key) => {
  const hideWarning = isTestEnvironment() || isProductionEnvironment();
  const messageId = key ?? fnName;
  if (displayedWarnings.has(messageId) || hideWarning) {
    return;
  }
  displayedWarnings.add(messageId);
  console.warn(
    `Clerk - DEPRECATION WARNING: "${fnName}" is deprecated and will be removed in the next major release.
${warning}`
  );
};
var deprecatedProperty = (cls, propName, warning, isStatic = false) => {
  const target = isStatic ? cls : cls.prototype;
  let value = target[propName];
  Object.defineProperty(target, propName, {
    get() {
      deprecated(propName, warning, `${cls.name}:${propName}`);
      return value;
    },
    set(v) {
      value = v;
    }
  });
};
var deprecatedObjectProperty = (obj, propName, warning, key) => {
  let value = obj[propName];
  Object.defineProperty(obj, propName, {
    get() {
      deprecated(propName, warning, key);
      return value;
    },
    set(v) {
      value = v;
    }
  });
};

// node_modules/@clerk/shared/dist/chunk-RUQRCEI6.mjs
function isStaging(frontendApi) {
  return frontendApi.endsWith(".lclstage.dev") || frontendApi.endsWith(".stgstage.dev") || frontendApi.endsWith(".clerkstage.dev") || frontendApi.endsWith(".accountsstage.dev");
}
function addClerkPrefix(str) {
  if (!str) {
    return "";
  }
  let regex;
  if (str.match(/^(clerk\.)+\w*$/)) {
    regex = /(clerk\.)*(?=clerk\.)/;
  } else if (str.match(/\.clerk.accounts/)) {
    return str;
  } else {
    regex = /^(clerk\.)*/gi;
  }
  const stripped = str.replace(regex, "");
  return `clerk.${stripped}`;
}
var getClerkJsMajorVersionOrTag = (frontendApi, pkgVersion) => {
  if (!pkgVersion && isStaging(frontendApi)) {
    return "staging";
  }
  if (!pkgVersion) {
    return "latest";
  }
  if (pkgVersion.includes("next")) {
    return "next";
  }
  return pkgVersion.split(".")[0] || "latest";
};
var getScriptUrl = (frontendApi, { pkgVersion, clerkJSVersion }) => {
  const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\/\//, "");
  const major = getClerkJsMajorVersionOrTag(frontendApi, pkgVersion);
  return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;
};

// node_modules/@clerk/shared/dist/chunk-4PW5MDZA.mjs
function wait(ms) {
  return new Promise((res) => setTimeout(res, ms));
}
var MAX_NUMBER_OF_RETRIES = 5;
async function callWithRetry(fn, attempt = 1, maxAttempts = MAX_NUMBER_OF_RETRIES) {
  try {
    return await fn();
  } catch (e) {
    if (attempt >= maxAttempts) {
      throw e;
    }
    await wait(2 ** attempt * 100);
    return callWithRetry(fn, attempt + 1, maxAttempts);
  }
}

// node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs
var isomorphicAtob = (data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") {
    return atob(data);
  } else if (typeof global !== "undefined" && global.Buffer) {
    return new global.Buffer(data, "base64").toString();
  }
  return data;
};

// node_modules/@clerk/shared/dist/chunk-IAZRYRAH.mjs
var PUBLISHABLE_KEY_LIVE_PREFIX = "pk_live_";
var PUBLISHABLE_KEY_TEST_PREFIX = "pk_test_";
function parsePublishableKey(key) {
  key = key || "";
  if (!isPublishableKey(key)) {
    return null;
  }
  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? "production" : "development";
  let frontendApi = isomorphicAtob(key.split("_")[2]);
  if (!frontendApi.endsWith("$")) {
    return null;
  }
  frontendApi = frontendApi.slice(0, -1);
  return {
    instanceType,
    frontendApi
  };
}
function isPublishableKey(key) {
  key = key || "";
  const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);
  const hasValidFrontendApiPostfix = isomorphicAtob(key.split("_")[2] || "").endsWith("$");
  return hasValidPrefix && hasValidFrontendApiPostfix;
}
function createDevOrStagingUrlCache() {
  const DEV_OR_STAGING_SUFFIXES = [
    ".lcl.dev",
    ".stg.dev",
    ".lclstage.dev",
    ".stgstage.dev",
    ".dev.lclclerk.com",
    ".stg.lclclerk.com",
    ".accounts.lclclerk.com",
    "accountsstage.dev",
    "accounts.dev"
  ];
  const devOrStagingUrlCache = /* @__PURE__ */ new Map();
  return {
    isDevOrStagingUrl: (url) => {
      if (!url) {
        return false;
      }
      const hostname = typeof url === "string" ? url : url.hostname;
      let res = devOrStagingUrlCache.get(hostname);
      if (res === void 0) {
        res = DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));
        devOrStagingUrlCache.set(hostname, res);
      }
      return res;
    }
  };
}
function isDevelopmentFromApiKey(apiKey) {
  return apiKey.startsWith("test_") || apiKey.startsWith("sk_test_");
}
function isProductionFromApiKey(apiKey) {
  return apiKey.startsWith("live_") || apiKey.startsWith("sk_live_");
}

// node_modules/@clerk/shared/dist/chunk-2O574DKN.mjs
var _MagicLinkErrorCode = {
  Expired: "expired",
  Failed: "failed"
};
var MagicLinkErrorCode = new Proxy(_MagicLinkErrorCode, {
  get(target, prop, receiver) {
    deprecated("MagicLinkErrorCode", "Use `EmailLinkErrorCode` instead.");
    return Reflect.get(target, prop, receiver);
  }
});
var DefaultMessages = Object.freeze({
  InvalidFrontendApiErrorMessage: `The frontendApi passed to Clerk is invalid. You can get your Frontend API key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`
});
function buildErrorThrower({ packageName, customMessages }) {
  let pkg = packageName;
  const messages = {
    ...DefaultMessages,
    ...customMessages
  };
  function buildMessage(rawMessage, replacements) {
    if (!replacements) {
      return `${pkg}: ${rawMessage}`;
    }
    let msg = rawMessage;
    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const match of matches) {
      const replacement = (replacements[match[1]] || "").toString();
      msg = msg.replace(`{{${match[1]}}}`, replacement);
    }
    return `${pkg}: ${msg}`;
  }
  return {
    setPackageName({ packageName: packageName2 }) {
      if (typeof packageName2 === "string") {
        pkg = packageName2;
      }
      return this;
    },
    setMessages({ customMessages: customMessages2 }) {
      Object.assign(messages, customMessages2 || {});
      return this;
    },
    throwInvalidPublishableKeyError(params) {
      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
    },
    throwInvalidFrontendApiError(params) {
      throw new Error(buildMessage(messages.InvalidFrontendApiErrorMessage, params));
    },
    throwInvalidProxyUrl(params) {
      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
    },
    throwMissingPublishableKeyError() {
      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
    }
  };
}

// node_modules/@clerk/backend/dist/runtime/browser/crypto.mjs
var crypto_default = crypto;

// node_modules/@clerk/backend/dist/runtime/browser/fetch.mjs
var fetch_exports = {};
__export(fetch_exports, {
  RuntimeAbortController: () => RuntimeAbortController,
  RuntimeBlob: () => RuntimeBlob,
  RuntimeFetch: () => RuntimeFetch,
  RuntimeFormData: () => RuntimeFormData,
  RuntimeHeaders: () => RuntimeHeaders,
  RuntimeRequest: () => RuntimeRequest,
  RuntimeResponse: () => RuntimeResponse,
  default: () => fetch_default
});
var fetch_default = fetch;
var RuntimeBlob = Blob;
var RuntimeFormData = FormData;
var RuntimeHeaders = Headers;
var RuntimeRequest = Request;
var RuntimeResponse = Response;
var RuntimeAbortController = AbortController;
var RuntimeFetch = fetch;

// node_modules/@clerk/backend/dist/esm/index.js
var import_deepmerge = __toESM(require_cjs());
var import_snakecase_keys = __toESM(require_snakecase_keys());
var import_cookie = __toESM(require_cookie());
var AbstractAPI = class {
  constructor(request) {
    this.request = request;
  }
  requireId(id) {
    if (!id) {
      throw new Error("A valid resource ID is required.");
    }
  }
};
var SEPARATOR = "/";
var MULTIPLE_SEPARATOR_REGEX = new RegExp(SEPARATOR + "{1,}", "g");
function joinPaths(...args) {
  return args.filter((p) => p).join(SEPARATOR).replace(MULTIPLE_SEPARATOR_REGEX, SEPARATOR);
}
var basePath = "/allowlist_identifiers";
var AllowlistIdentifierAPI = class extends AbstractAPI {
  async getAllowlistIdentifierList() {
    return this.request({
      method: "GET",
      path: basePath
    });
  }
  async createAllowlistIdentifier(params) {
    return this.request({
      method: "POST",
      path: basePath,
      bodyParams: params
    });
  }
  async deleteAllowlistIdentifier(allowlistIdentifierId) {
    this.requireId(allowlistIdentifierId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath, allowlistIdentifierId)
    });
  }
};
var basePath2 = "/clients";
var ClientAPI = class extends AbstractAPI {
  async getClientList() {
    return this.request({
      method: "GET",
      path: basePath2
    });
  }
  async getClient(clientId) {
    this.requireId(clientId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath2, clientId)
    });
  }
  verifyClient(token) {
    return this.request({
      method: "POST",
      path: joinPaths(basePath2, "verify"),
      bodyParams: { token }
    });
  }
};
var basePath3 = "/domains";
var DomainAPI = class extends AbstractAPI {
  async deleteDomain(id) {
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath3, id)
    });
  }
};
var basePath4 = "/email_addresses";
var EmailAddressAPI = class extends AbstractAPI {
  async getEmailAddress(emailAddressId) {
    this.requireId(emailAddressId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath4, emailAddressId)
    });
  }
  async createEmailAddress(params) {
    return this.request({
      method: "POST",
      path: basePath4,
      bodyParams: params
    });
  }
  async updateEmailAddress(emailAddressId, params = {}) {
    this.requireId(emailAddressId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath4, emailAddressId),
      bodyParams: params
    });
  }
  async deleteEmailAddress(emailAddressId) {
    this.requireId(emailAddressId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath4, emailAddressId)
    });
  }
};
var basePath5 = "/emails";
var EmailAPI = class extends AbstractAPI {
  async createEmail(params) {
    return this.request({
      method: "POST",
      path: basePath5,
      bodyParams: params
    });
  }
};
var errorThrower = buildErrorThrower({ packageName: "@clerk/backend" });
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();
var InterstitialAPI = class extends AbstractAPI {
  async getInterstitial() {
    deprecated(
      "getInterstitial()",
      'Switch to `Clerk(...).localInterstitial(...)` from `import { Clerk } from "@clerk/backend"`.'
    );
    return this.request({
      path: "internal/interstitial",
      method: "GET",
      headerParams: {
        "Content-Type": "text/html"
      }
    });
  }
};
var basePath6 = "/invitations";
var InvitationAPI = class extends AbstractAPI {
  async getInvitationList(params = {}) {
    return this.request({
      method: "GET",
      path: basePath6,
      queryParams: params
    });
  }
  async createInvitation(params) {
    return this.request({
      method: "POST",
      path: basePath6,
      bodyParams: params
    });
  }
  async revokeInvitation(invitationId) {
    this.requireId(invitationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath6, invitationId, "revoke")
    });
  }
};
var {
  RuntimeFetch: RuntimeFetch2,
  RuntimeAbortController: RuntimeAbortController2,
  RuntimeBlob: RuntimeBlob2,
  RuntimeFormData: RuntimeFormData2,
  RuntimeHeaders: RuntimeHeaders2,
  RuntimeRequest: RuntimeRequest2,
  RuntimeResponse: RuntimeResponse2
} = fetch_exports;
var globalFetch = RuntimeFetch2.bind(globalThis);
var runtime = {
  crypto: crypto_default,
  fetch: globalFetch,
  AbortController: RuntimeAbortController2,
  Blob: RuntimeBlob2,
  FormData: RuntimeFormData2,
  Headers: RuntimeHeaders2,
  Request: RuntimeRequest2,
  Response: RuntimeResponse2
};
var runtime_default = runtime;
var basePath7 = "/organizations";
var OrganizationAPI = class extends AbstractAPI {
  async getOrganizationList(params) {
    return this.request({
      method: "GET",
      path: basePath7,
      queryParams: params
    });
  }
  async createOrganization(params) {
    return this.request({
      method: "POST",
      path: basePath7,
      bodyParams: params
    });
  }
  async getOrganization(params) {
    const organizationIdOrSlug = "organizationId" in params ? params.organizationId : params.slug;
    this.requireId(organizationIdOrSlug);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationIdOrSlug)
    });
  }
  async updateOrganization(organizationId, params) {
    this.requireId(organizationId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId),
      bodyParams: params
    });
  }
  async updateOrganizationLogo(organizationId, params) {
    this.requireId(organizationId);
    const formData = new runtime_default.FormData();
    formData.append("file", params == null ? void 0 : params.file);
    formData.append("uploader_user_id", params == null ? void 0 : params.uploaderUserId);
    return this.request({
      method: "PUT",
      path: joinPaths(basePath7, organizationId, "logo"),
      formData
    });
  }
  async deleteOrganizationLogo(organizationId) {
    this.requireId(organizationId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath7, organizationId, "logo")
    });
  }
  async updateOrganizationMetadata(organizationId, params) {
    this.requireId(organizationId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId, "metadata"),
      bodyParams: params
    });
  }
  async deleteOrganization(organizationId) {
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath7, organizationId)
    });
  }
  async getOrganizationMembershipList(params) {
    const { organizationId, limit, offset } = params;
    this.requireId(organizationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "memberships"),
      queryParams: { limit, offset }
    });
  }
  async createOrganizationMembership(params) {
    const { organizationId, userId, role } = params;
    this.requireId(organizationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath7, organizationId, "memberships"),
      bodyParams: {
        userId,
        role
      }
    });
  }
  async updateOrganizationMembership(params) {
    const { organizationId, userId, role } = params;
    this.requireId(organizationId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId, "memberships", userId),
      bodyParams: {
        role
      }
    });
  }
  async updateOrganizationMembershipMetadata(params) {
    const { organizationId, userId, publicMetadata, privateMetadata } = params;
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId, "memberships", userId, "metadata"),
      bodyParams: {
        publicMetadata,
        privateMetadata
      }
    });
  }
  async deleteOrganizationMembership(params) {
    const { organizationId, userId } = params;
    this.requireId(organizationId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath7, organizationId, "memberships", userId)
    });
  }
  async getOrganizationInvitationList(params) {
    const { organizationId, status, limit, offset } = params;
    this.requireId(organizationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "invitations"),
      queryParams: { status, limit, offset }
    });
  }
  /**
   * @deprecated  Use `getOrganizationInvitationList` instead along with the status parameter.
   */
  async getPendingOrganizationInvitationList(params) {
    deprecated("getPendingOrganizationInvitationList", "Use `getOrganizationInvitationList` instead.");
    const { organizationId, limit, offset } = params;
    this.requireId(organizationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "invitations", "pending"),
      queryParams: { limit, offset }
    });
  }
  async createOrganizationInvitation(params) {
    const { organizationId, ...bodyParams } = params;
    this.requireId(organizationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath7, organizationId, "invitations"),
      bodyParams: { ...bodyParams }
    });
  }
  async getOrganizationInvitation(params) {
    const { organizationId, invitationId } = params;
    this.requireId(organizationId);
    this.requireId(invitationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "invitations", invitationId)
    });
  }
  async revokeOrganizationInvitation(params) {
    const { organizationId, invitationId, requestingUserId } = params;
    this.requireId(organizationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath7, organizationId, "invitations", invitationId, "revoke"),
      bodyParams: {
        requestingUserId
      }
    });
  }
};
var basePath8 = "/phone_numbers";
var PhoneNumberAPI = class extends AbstractAPI {
  async getPhoneNumber(phoneNumberId) {
    this.requireId(phoneNumberId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath8, phoneNumberId)
    });
  }
  async createPhoneNumber(params) {
    return this.request({
      method: "POST",
      path: basePath8,
      bodyParams: params
    });
  }
  async updatePhoneNumber(phoneNumberId, params = {}) {
    this.requireId(phoneNumberId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath8, phoneNumberId),
      bodyParams: params
    });
  }
  async deletePhoneNumber(phoneNumberId) {
    this.requireId(phoneNumberId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath8, phoneNumberId)
    });
  }
};
var basePath9 = "/redirect_urls";
var RedirectUrlAPI = class extends AbstractAPI {
  async getRedirectUrlList() {
    return this.request({
      method: "GET",
      path: basePath9
    });
  }
  async getRedirectUrl(redirectUrlId) {
    this.requireId(redirectUrlId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath9, redirectUrlId)
    });
  }
  async createRedirectUrl(params) {
    return this.request({
      method: "POST",
      path: basePath9,
      bodyParams: params
    });
  }
  async deleteRedirectUrl(redirectUrlId) {
    this.requireId(redirectUrlId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath9, redirectUrlId)
    });
  }
};
var basePath10 = "/sessions";
var SessionAPI = class extends AbstractAPI {
  async getSessionList(queryParams) {
    return this.request({
      method: "GET",
      path: basePath10,
      queryParams
    });
  }
  async getSession(sessionId) {
    this.requireId(sessionId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath10, sessionId)
    });
  }
  async revokeSession(sessionId) {
    this.requireId(sessionId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath10, sessionId, "revoke")
    });
  }
  async verifySession(sessionId, token) {
    this.requireId(sessionId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath10, sessionId, "verify"),
      bodyParams: { token }
    });
  }
  async getToken(sessionId, template) {
    this.requireId(sessionId);
    return (await this.request({
      method: "POST",
      path: joinPaths(basePath10, sessionId, "tokens", template || "")
    })).jwt;
  }
};
var basePath11 = "/sign_in_tokens";
var SignInTokenAPI = class extends AbstractAPI {
  async createSignInToken(params) {
    return this.request({
      method: "POST",
      path: basePath11,
      bodyParams: params
    });
  }
  async revokeSignInToken(signInTokenId) {
    this.requireId(signInTokenId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath11, signInTokenId, "revoke")
    });
  }
};
var basePath12 = "/sms_messages";
var SMSMessageAPI = class extends AbstractAPI {
  async createSMSMessage(params) {
    return this.request({
      method: "POST",
      path: basePath12,
      bodyParams: params
    });
  }
};
var basePath13 = "/users";
var UserAPI = class extends AbstractAPI {
  async getUserList(params = {}) {
    return this.request({
      method: "GET",
      path: basePath13,
      queryParams: params
    });
  }
  async getUser(userId) {
    this.requireId(userId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, userId)
    });
  }
  async createUser(params) {
    return this.request({
      method: "POST",
      path: basePath13,
      bodyParams: params
    });
  }
  async updateUser(userId, params = {}) {
    this.requireId(userId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath13, userId),
      bodyParams: params
    });
  }
  async updateUserProfileImage(userId, params) {
    this.requireId(userId);
    const formData = new runtime_default.FormData();
    formData.append("file", params == null ? void 0 : params.file);
    return this.request({
      method: "POST",
      path: joinPaths(basePath13, userId, "profile_image"),
      formData
    });
  }
  async updateUserMetadata(userId, params) {
    this.requireId(userId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath13, userId, "metadata"),
      bodyParams: params
    });
  }
  async deleteUser(userId) {
    this.requireId(userId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath13, userId)
    });
  }
  async getCount(params = {}) {
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, "count"),
      queryParams: params
    });
  }
  async getUserOauthAccessToken(userId, provider) {
    this.requireId(userId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, userId, "oauth_access_tokens", provider)
    });
  }
  async disableUserMFA(userId) {
    this.requireId(userId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath13, userId, "mfa")
    });
  }
  async getOrganizationMembershipList(params) {
    const { userId, limit, offset } = params;
    this.requireId(userId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, userId, "organization_memberships"),
      queryParams: { limit, offset }
    });
  }
  async verifyPassword(params) {
    const { userId, password } = params;
    this.requireId(userId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath13, userId, "verify_password"),
      bodyParams: { password }
    });
  }
  async verifyTOTP(params) {
    const { userId, code } = params;
    this.requireId(userId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath13, userId, "verify_totp"),
      bodyParams: { code }
    });
  }
};
var API_URL = "https://api.clerk.dev";
var API_VERSION = "v1";
var USER_AGENT = `@clerk/backend`;
var MAX_CACHE_LAST_UPDATED_AT_SECONDS = 5 * 60;
var Attributes = {
  AuthStatus: "__clerkAuthStatus",
  AuthReason: "__clerkAuthReason",
  AuthMessage: "__clerkAuthMessage"
};
var Cookies = {
  Session: "__session",
  ClientUat: "__client_uat"
};
var Headers2 = {
  AuthStatus: "x-clerk-auth-status",
  AuthReason: "x-clerk-auth-reason",
  AuthMessage: "x-clerk-auth-message",
  EnableDebug: "x-clerk-debug",
  ClerkRedirectTo: "x-clerk-redirect-to",
  CloudFrontForwardedProto: "cloudfront-forwarded-proto",
  Authorization: "authorization",
  ForwardedPort: "x-forwarded-port",
  ForwardedProto: "x-forwarded-proto",
  ForwardedHost: "x-forwarded-host",
  Referrer: "referer",
  UserAgent: "user-agent",
  Origin: "origin",
  Host: "host",
  ContentType: "content-type"
};
var SearchParams = {
  AuthStatus: Headers2.AuthStatus
};
var ContentTypes = {
  Json: "application/json"
};
var constants = {
  Attributes,
  Cookies,
  Headers: Headers2,
  SearchParams,
  ContentTypes
};
function assertValidSecretKey(val) {
  if (!val || typeof val !== "string") {
    throw Error(
      "Missing Clerk Secret Key or API Key. Go to https://dashboard.clerk.com and get your key for your instance."
    );
  }
}
var AllowlistIdentifier = class _AllowlistIdentifier {
  constructor(id, identifier, createdAt, updatedAt, invitationId) {
    this.id = id;
    this.identifier = identifier;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.invitationId = invitationId;
  }
  static fromJSON(data) {
    return new _AllowlistIdentifier(data.id, data.identifier, data.created_at, data.updated_at, data.invitation_id);
  }
};
var Session = class _Session {
  constructor(id, clientId, userId, status, lastActiveAt, expireAt, abandonAt, createdAt, updatedAt) {
    this.id = id;
    this.clientId = clientId;
    this.userId = userId;
    this.status = status;
    this.lastActiveAt = lastActiveAt;
    this.expireAt = expireAt;
    this.abandonAt = abandonAt;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new _Session(
      data.id,
      data.client_id,
      data.user_id,
      data.status,
      data.last_active_at,
      data.expire_at,
      data.abandon_at,
      data.created_at,
      data.updated_at
    );
  }
};
var Client = class _Client {
  constructor(id, sessionIds, sessions, signInId, signUpId, lastActiveSessionId, createdAt, updatedAt) {
    this.id = id;
    this.sessionIds = sessionIds;
    this.sessions = sessions;
    this.signInId = signInId;
    this.signUpId = signUpId;
    this.lastActiveSessionId = lastActiveSessionId;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new _Client(
      data.id,
      data.session_ids,
      data.sessions.map((x) => Session.fromJSON(x)),
      data.sign_in_id,
      data.sign_up_id,
      data.last_active_session_id,
      data.created_at,
      data.updated_at
    );
  }
};
var DeletedObject = class _DeletedObject {
  constructor(object, id, slug, deleted) {
    this.object = object;
    this.id = id;
    this.slug = slug;
    this.deleted = deleted;
  }
  static fromJSON(data) {
    return new _DeletedObject(data.object, data.id || null, data.slug || null, data.deleted);
  }
};
var Email = class _Email {
  constructor(id, fromEmailName, emailAddressId, toEmailAddress, subject, body, bodyPlain, status, slug, data, deliveredByClerk) {
    this.id = id;
    this.fromEmailName = fromEmailName;
    this.emailAddressId = emailAddressId;
    this.toEmailAddress = toEmailAddress;
    this.subject = subject;
    this.body = body;
    this.bodyPlain = bodyPlain;
    this.status = status;
    this.slug = slug;
    this.data = data;
    this.deliveredByClerk = deliveredByClerk;
  }
  static fromJSON(data) {
    return new _Email(
      data.id,
      data.from_email_name,
      data.email_address_id,
      data.to_email_address,
      data.subject,
      data.body,
      data.body_plain,
      data.status,
      data.slug,
      data.data,
      data.delivered_by_clerk
    );
  }
};
var IdentificationLink = class _IdentificationLink {
  constructor(id, type) {
    this.id = id;
    this.type = type;
  }
  static fromJSON(data) {
    return new _IdentificationLink(data.id, data.type);
  }
};
var Verification = class _Verification {
  constructor(status, strategy, externalVerificationRedirectURL = null, attempts = null, expireAt = null, nonce = null) {
    this.status = status;
    this.strategy = strategy;
    this.externalVerificationRedirectURL = externalVerificationRedirectURL;
    this.attempts = attempts;
    this.expireAt = expireAt;
    this.nonce = nonce;
  }
  static fromJSON(data) {
    return new _Verification(
      data.status,
      data.strategy,
      data.external_verification_redirect_url ? new URL(data.external_verification_redirect_url) : null,
      data.attempts,
      data.expire_at,
      data.nonce
    );
  }
};
var EmailAddress = class _EmailAddress {
  constructor(id, emailAddress, verification, linkedTo) {
    this.id = id;
    this.emailAddress = emailAddress;
    this.verification = verification;
    this.linkedTo = linkedTo;
  }
  static fromJSON(data) {
    return new _EmailAddress(
      data.id,
      data.email_address,
      data.verification && Verification.fromJSON(data.verification),
      data.linked_to.map((link) => IdentificationLink.fromJSON(link))
    );
  }
};
var ExternalAccount = class _ExternalAccount {
  constructor(id, provider, identificationId, externalId, approvedScopes, emailAddress, firstName, lastName, picture, imageUrl, username, publicMetadata = {}, label, verification) {
    this.id = id;
    this.provider = provider;
    this.identificationId = identificationId;
    this.externalId = externalId;
    this.approvedScopes = approvedScopes;
    this.emailAddress = emailAddress;
    this.firstName = firstName;
    this.lastName = lastName;
    this.picture = picture;
    this.imageUrl = imageUrl;
    this.username = username;
    this.publicMetadata = publicMetadata;
    this.label = label;
    this.verification = verification;
  }
  static fromJSON(data) {
    return new _ExternalAccount(
      data.id,
      data.provider,
      data.identification_id,
      data.provider_user_id,
      data.approved_scopes,
      data.email_address,
      data.first_name,
      data.last_name,
      data.avatar_url,
      data.image_url,
      data.username,
      data.public_metadata,
      data.label,
      data.verification && Verification.fromJSON(data.verification)
    );
  }
};
deprecatedProperty(ExternalAccount, "picture", "Use `imageUrl` instead.");
var Invitation = class _Invitation {
  constructor(id, emailAddress, publicMetadata, createdAt, updatedAt, status, revoked) {
    this.id = id;
    this.emailAddress = emailAddress;
    this.publicMetadata = publicMetadata;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.status = status;
    this.revoked = revoked;
  }
  static fromJSON(data) {
    return new _Invitation(
      data.id,
      data.email_address,
      data.public_metadata,
      data.created_at,
      data.updated_at,
      data.status,
      data.revoked
    );
  }
};
var ObjectType = ((ObjectType2) => {
  ObjectType2["AllowlistIdentifier"] = "allowlist_identifier";
  ObjectType2["Client"] = "client";
  ObjectType2["Email"] = "email";
  ObjectType2["EmailAddress"] = "email_address";
  ObjectType2["ExternalAccount"] = "external_account";
  ObjectType2["FacebookAccount"] = "facebook_account";
  ObjectType2["GoogleAccount"] = "google_account";
  ObjectType2["Invitation"] = "invitation";
  ObjectType2["OauthAccessToken"] = "oauth_access_token";
  ObjectType2["Organization"] = "organization";
  ObjectType2["OrganizationInvitation"] = "organization_invitation";
  ObjectType2["OrganizationMembership"] = "organization_membership";
  ObjectType2["PhoneNumber"] = "phone_number";
  ObjectType2["RedirectUrl"] = "redirect_url";
  ObjectType2["Session"] = "session";
  ObjectType2["SignInAttempt"] = "sign_in_attempt";
  ObjectType2["SignInToken"] = "sign_in_token";
  ObjectType2["SignUpAttempt"] = "sign_up_attempt";
  ObjectType2["SmsMessage"] = "sms_message";
  ObjectType2["User"] = "user";
  ObjectType2["Web3Wallet"] = "web3_wallet";
  ObjectType2["Token"] = "token";
  ObjectType2["TotalCount"] = "total_count";
  return ObjectType2;
})(ObjectType || {});
var OauthAccessToken = class _OauthAccessToken {
  constructor(provider, token, publicMetadata = {}, label, scopes, tokenSecret) {
    this.provider = provider;
    this.token = token;
    this.publicMetadata = publicMetadata;
    this.label = label;
    this.scopes = scopes;
    this.tokenSecret = tokenSecret;
  }
  static fromJSON(data) {
    return new _OauthAccessToken(
      data.provider,
      data.token,
      data.public_metadata,
      data.label,
      data.scopes,
      data.token_secret
    );
  }
};
var Organization = class _Organization {
  constructor(id, name, slug, logoUrl, imageUrl, hasImage, createdBy, createdAt, updatedAt, publicMetadata = {}, privateMetadata = {}, maxAllowedMemberships, adminDeleteEnabled, members_count) {
    this.id = id;
    this.name = name;
    this.slug = slug;
    this.logoUrl = logoUrl;
    this.imageUrl = imageUrl;
    this.hasImage = hasImage;
    this.createdBy = createdBy;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
    this.maxAllowedMemberships = maxAllowedMemberships;
    this.adminDeleteEnabled = adminDeleteEnabled;
    this.members_count = members_count;
  }
  static fromJSON(data) {
    return new _Organization(
      data.id,
      data.name,
      data.slug,
      data.logo_url,
      data.image_url,
      data.has_image,
      data.created_by,
      data.created_at,
      data.updated_at,
      data.public_metadata,
      data.private_metadata,
      data.max_allowed_memberships,
      data.admin_delete_enabled,
      data.members_count
    );
  }
};
deprecatedProperty(Organization, "logoUrl", "Use `imageUrl` instead.");
var OrganizationInvitation = class _OrganizationInvitation {
  constructor(id, emailAddress, role, organizationId, createdAt, updatedAt, status, publicMetadata = {}, privateMetadata = {}) {
    this.id = id;
    this.emailAddress = emailAddress;
    this.role = role;
    this.organizationId = organizationId;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.status = status;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
  }
  static fromJSON(data) {
    return new _OrganizationInvitation(
      data.id,
      data.email_address,
      data.role,
      data.organization_id,
      data.created_at,
      data.updated_at,
      data.status,
      data.public_metadata,
      data.private_metadata
    );
  }
};
var OrganizationMembership = class _OrganizationMembership {
  constructor(id, role, publicMetadata = {}, privateMetadata = {}, createdAt, updatedAt, organization, publicUserData) {
    this.id = id;
    this.role = role;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.organization = organization;
    this.publicUserData = publicUserData;
  }
  static fromJSON(data) {
    return new _OrganizationMembership(
      data.id,
      data.role,
      data.public_metadata,
      data.private_metadata,
      data.created_at,
      data.updated_at,
      Organization.fromJSON(data.organization),
      OrganizationMembershipPublicUserData.fromJSON(data.public_user_data)
    );
  }
};
var OrganizationMembershipPublicUserData = class _OrganizationMembershipPublicUserData {
  constructor(identifier, firstName, lastName, profileImageUrl, imageUrl, hasImage, userId) {
    this.identifier = identifier;
    this.firstName = firstName;
    this.lastName = lastName;
    this.profileImageUrl = profileImageUrl;
    this.imageUrl = imageUrl;
    this.hasImage = hasImage;
    this.userId = userId;
  }
  static fromJSON(data) {
    return new _OrganizationMembershipPublicUserData(
      data.identifier,
      data.first_name,
      data.last_name,
      data.profile_image_url,
      data.image_url,
      data.has_image,
      data.user_id
    );
  }
};
deprecatedProperty(OrganizationMembershipPublicUserData, "profileImageUrl", "Use `imageUrl` instead.");
var PhoneNumber = class _PhoneNumber {
  constructor(id, phoneNumber, reservedForSecondFactor, defaultSecondFactor, verification, linkedTo) {
    this.id = id;
    this.phoneNumber = phoneNumber;
    this.reservedForSecondFactor = reservedForSecondFactor;
    this.defaultSecondFactor = defaultSecondFactor;
    this.verification = verification;
    this.linkedTo = linkedTo;
  }
  static fromJSON(data) {
    return new _PhoneNumber(
      data.id,
      data.phone_number,
      data.reserved_for_second_factor,
      data.default_second_factor,
      data.verification && Verification.fromJSON(data.verification),
      data.linked_to.map((link) => IdentificationLink.fromJSON(link))
    );
  }
};
var RedirectUrl = class _RedirectUrl {
  constructor(id, url, createdAt, updatedAt) {
    this.id = id;
    this.url = url;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new _RedirectUrl(data.id, data.url, data.created_at, data.updated_at);
  }
};
var SignInToken = class _SignInToken {
  constructor(id, userId, token, status, url, createdAt, updatedAt) {
    this.id = id;
    this.userId = userId;
    this.token = token;
    this.status = status;
    this.url = url;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new _SignInToken(data.id, data.user_id, data.token, data.status, data.url, data.created_at, data.updated_at);
  }
};
var SMSMessage = class _SMSMessage {
  constructor(id, fromPhoneNumber, toPhoneNumber, message, status, phoneNumberId, data) {
    this.id = id;
    this.fromPhoneNumber = fromPhoneNumber;
    this.toPhoneNumber = toPhoneNumber;
    this.message = message;
    this.status = status;
    this.phoneNumberId = phoneNumberId;
    this.data = data;
  }
  static fromJSON(data) {
    return new _SMSMessage(
      data.id,
      data.from_phone_number,
      data.to_phone_number,
      data.message,
      data.status,
      data.phone_number_id,
      data.data
    );
  }
};
var Token = class _Token {
  constructor(jwt) {
    this.jwt = jwt;
  }
  static fromJSON(data) {
    return new _Token(data.jwt);
  }
};
var Web3Wallet = class _Web3Wallet {
  constructor(id, web3Wallet, verification) {
    this.id = id;
    this.web3Wallet = web3Wallet;
    this.verification = verification;
  }
  static fromJSON(data) {
    return new _Web3Wallet(data.id, data.web3_wallet, data.verification && Verification.fromJSON(data.verification));
  }
};
var User = class _User {
  constructor(id, passwordEnabled, totpEnabled, backupCodeEnabled, twoFactorEnabled, banned, createdAt, updatedAt, profileImageUrl, imageUrl, hasImage, gender, birthday, primaryEmailAddressId, primaryPhoneNumberId, primaryWeb3WalletId, lastSignInAt, externalId, username, firstName, lastName, publicMetadata = {}, privateMetadata = {}, unsafeMetadata = {}, emailAddresses = [], phoneNumbers = [], web3Wallets = [], externalAccounts = []) {
    this.id = id;
    this.passwordEnabled = passwordEnabled;
    this.totpEnabled = totpEnabled;
    this.backupCodeEnabled = backupCodeEnabled;
    this.twoFactorEnabled = twoFactorEnabled;
    this.banned = banned;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.profileImageUrl = profileImageUrl;
    this.imageUrl = imageUrl;
    this.hasImage = hasImage;
    this.gender = gender;
    this.birthday = birthday;
    this.primaryEmailAddressId = primaryEmailAddressId;
    this.primaryPhoneNumberId = primaryPhoneNumberId;
    this.primaryWeb3WalletId = primaryWeb3WalletId;
    this.lastSignInAt = lastSignInAt;
    this.externalId = externalId;
    this.username = username;
    this.firstName = firstName;
    this.lastName = lastName;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
    this.unsafeMetadata = unsafeMetadata;
    this.emailAddresses = emailAddresses;
    this.phoneNumbers = phoneNumbers;
    this.web3Wallets = web3Wallets;
    this.externalAccounts = externalAccounts;
  }
  static fromJSON(data) {
    return new _User(
      data.id,
      data.password_enabled,
      data.totp_enabled,
      data.backup_code_enabled,
      data.two_factor_enabled,
      data.banned,
      data.created_at,
      data.updated_at,
      data.profile_image_url,
      data.image_url,
      data.has_image,
      data.gender,
      data.birthday,
      data.primary_email_address_id,
      data.primary_phone_number_id,
      data.primary_web3_wallet_id,
      data.last_sign_in_at,
      data.external_id,
      data.username,
      data.first_name,
      data.last_name,
      data.public_metadata,
      data.private_metadata,
      data.unsafe_metadata,
      (data.email_addresses || []).map((x) => EmailAddress.fromJSON(x)),
      (data.phone_numbers || []).map((x) => PhoneNumber.fromJSON(x)),
      (data.web3_wallets || []).map((x) => Web3Wallet.fromJSON(x)),
      (data.external_accounts || []).map((x) => ExternalAccount.fromJSON(x))
    );
  }
};
deprecatedProperty(User, "profileImageUrl", "Use `imageUrl` instead.");
function deserialize(payload) {
  if (Array.isArray(payload)) {
    return payload.map((item) => jsonToObject(item));
  } else if (isPaginated(payload)) {
    return payload.data.map((item) => jsonToObject(item));
  } else {
    return jsonToObject(payload);
  }
}
function isPaginated(payload) {
  return Array.isArray(payload.data) && payload.data !== void 0;
}
function getCount(item) {
  return item.total_count;
}
function jsonToObject(item) {
  if (typeof item !== "string" && "object" in item && "deleted" in item) {
    return DeletedObject.fromJSON(item);
  }
  switch (item.object) {
    case "allowlist_identifier":
      return AllowlistIdentifier.fromJSON(item);
    case "client":
      return Client.fromJSON(item);
    case "email_address":
      return EmailAddress.fromJSON(item);
    case "email":
      return Email.fromJSON(item);
    case "invitation":
      return Invitation.fromJSON(item);
    case "oauth_access_token":
      return OauthAccessToken.fromJSON(item);
    case "organization":
      return Organization.fromJSON(item);
    case "organization_invitation":
      return OrganizationInvitation.fromJSON(item);
    case "organization_membership":
      return OrganizationMembership.fromJSON(item);
    case "phone_number":
      return PhoneNumber.fromJSON(item);
    case "redirect_url":
      return RedirectUrl.fromJSON(item);
    case "sign_in_token":
      return SignInToken.fromJSON(item);
    case "session":
      return Session.fromJSON(item);
    case "sms_message":
      return SMSMessage.fromJSON(item);
    case "token":
      return Token.fromJSON(item);
    case "total_count":
      return getCount(item);
    case "user":
      return User.fromJSON(item);
    default:
      return item;
  }
}
var withLegacyReturn = (cb) => async (...args) => {
  const { data, errors, status, statusText } = await cb(...args);
  if (errors === null) {
    return data;
  } else {
    throw new ClerkAPIResponseError2(statusText || "", {
      data: errors,
      status: status || ""
    });
  }
};
function buildRequest(options) {
  const request = async (requestOptions) => {
    var _a;
    const {
      apiKey,
      secretKey,
      httpOptions,
      apiUrl = API_URL,
      apiVersion = API_VERSION,
      userAgent = USER_AGENT
    } = options;
    if (apiKey) {
      deprecated("apiKey", "Use `secretKey` instead.");
    }
    if (httpOptions) {
      deprecated(
        "httpOptions",
        "This option has been deprecated and will be removed with the next major release.\nA RequestInit init object used by the `request` method."
      );
    }
    const { path, method, queryParams, headerParams, bodyParams, formData } = requestOptions;
    const key = secretKey || apiKey;
    assertValidSecretKey(key);
    const url = joinPaths(apiUrl, apiVersion, path);
    const finalUrl = new URL(url);
    if (queryParams) {
      const snakecasedQueryParams = (0, import_snakecase_keys.default)({ ...queryParams });
      for (const [key2, val] of Object.entries(snakecasedQueryParams)) {
        if (val) {
          [val].flat().forEach((v) => finalUrl.searchParams.append(key2, v));
        }
      }
    }
    const headers = {
      Authorization: `Bearer ${key}`,
      "Clerk-Backend-SDK": userAgent,
      ...headerParams
    };
    let res = void 0;
    try {
      if (formData) {
        res = await runtime_default.fetch(finalUrl.href, {
          ...httpOptions,
          method,
          headers,
          body: formData
        });
      } else {
        headers["Content-Type"] = "application/json";
        const hasBody = method !== "GET" && bodyParams && Object.keys(bodyParams).length > 0;
        const body = hasBody ? { body: JSON.stringify((0, import_snakecase_keys.default)(bodyParams, { deep: false })) } : null;
        res = await runtime_default.fetch(
          finalUrl.href,
          (0, import_deepmerge.default)(httpOptions || {}, {
            method,
            headers,
            ...body
          })
        );
      }
      const isJSONResponse = (res == null ? void 0 : res.headers) && ((_a = res.headers) == null ? void 0 : _a.get(constants.Headers.ContentType)) === constants.ContentTypes.Json;
      const data = await (isJSONResponse ? res.json() : res.text());
      if (!res.ok) {
        throw data;
      }
      return {
        data: deserialize(data),
        errors: null
      };
    } catch (err) {
      if (err instanceof Error) {
        return {
          data: null,
          errors: [
            {
              code: "unexpected_error",
              message: err.message || "Unexpected error"
            }
          ]
        };
      }
      return {
        data: null,
        errors: parseErrors2(err),
        // TODO: To be removed with withLegacyReturn
        // @ts-expect-error
        status: res == null ? void 0 : res.status,
        statusText: res == null ? void 0 : res.statusText
      };
    }
  };
  return withLegacyReturn(request);
}
function parseErrors2(data) {
  if (!!data && typeof data === "object" && "errors" in data) {
    const errors = data.errors;
    return errors.length > 0 ? errors.map(parseError2) : [];
  }
  return [];
}
function parseError2(error) {
  var _a, _b;
  return {
    code: error.code,
    message: error.message,
    longMessage: error.long_message,
    meta: {
      paramName: (_a = error == null ? void 0 : error.meta) == null ? void 0 : _a.param_name,
      sessionId: (_b = error == null ? void 0 : error.meta) == null ? void 0 : _b.session_id
    }
  };
}
var ClerkAPIResponseError2 = class _ClerkAPIResponseError extends Error {
  constructor(message, { data, status }) {
    super(message);
    Object.setPrototypeOf(this, _ClerkAPIResponseError.prototype);
    this.clerkError = true;
    this.message = message;
    this.status = status;
    this.errors = data;
  }
};
function createBackendApiClient(options) {
  const request = buildRequest(options);
  return {
    allowlistIdentifiers: new AllowlistIdentifierAPI(request),
    clients: new ClientAPI(request),
    emailAddresses: new EmailAddressAPI(request),
    emails: new EmailAPI(request),
    interstitial: new InterstitialAPI(request),
    invitations: new InvitationAPI(request),
    organizations: new OrganizationAPI(request),
    phoneNumbers: new PhoneNumberAPI(request),
    redirectUrls: new RedirectUrlAPI(request),
    sessions: new SessionAPI(request),
    signInTokens: new SignInTokenAPI(request),
    smsMessages: new SMSMessageAPI(request),
    users: new UserAPI(request),
    domains: new DomainAPI(request)
  };
}
var createDebug = (data) => {
  return () => {
    const res = { ...data };
    res.apiKey = (res.apiKey || "").substring(0, 7);
    res.secretKey = (res.secretKey || "").substring(0, 7);
    res.jwtKey = (res.jwtKey || "").substring(0, 7);
    return { ...res };
  };
};
function signedInAuthObject(sessionClaims, options, debugData) {
  const {
    act: actor,
    sid: sessionId,
    org_id: orgId,
    org_role: orgRole,
    org_slug: orgSlug,
    sub: userId
  } = sessionClaims;
  const { apiKey, secretKey, apiUrl, apiVersion, token, session, user, organization } = options;
  if (apiKey) {
    deprecated("apiKey", "Use `secretKey` instead.");
  }
  const { sessions } = createBackendApiClient({
    apiKey,
    secretKey,
    apiUrl,
    apiVersion
  });
  const getToken = createGetToken({
    sessionId,
    sessionToken: token,
    fetcher: (...args) => sessions.getToken(...args)
  });
  return {
    actor,
    sessionClaims,
    sessionId,
    session,
    userId,
    user,
    orgId,
    orgRole,
    orgSlug,
    organization,
    getToken,
    debug: createDebug({ ...options, ...debugData })
  };
}
function signedOutAuthObject(debugData) {
  if (debugData == null ? void 0 : debugData.apiKey) {
    deprecated("apiKey", "Use `secretKey` instead.");
  }
  return {
    sessionClaims: null,
    sessionId: null,
    session: null,
    userId: null,
    user: null,
    actor: null,
    orgId: null,
    orgRole: null,
    orgSlug: null,
    organization: null,
    getToken: () => Promise.resolve(null),
    debug: createDebug(debugData)
  };
}
function prunePrivateMetadata(resource) {
  if (resource) {
    delete resource["privateMetadata"];
    delete resource["private_metadata"];
  }
  return resource;
}
function sanitizeAuthObject(authObject) {
  const user = authObject.user ? { ...authObject.user } : authObject.user;
  const organization = authObject.organization ? { ...authObject.organization } : authObject.organization;
  prunePrivateMetadata(user);
  prunePrivateMetadata(organization);
  return { ...authObject, user, organization };
}
var makeAuthObjectSerializable = (obj) => {
  const { debug, getToken, ...rest } = obj;
  return rest;
};
var createGetToken = (params) => {
  const { fetcher, sessionToken, sessionId } = params || {};
  return async (options = {}) => {
    if (!sessionId) {
      return null;
    }
    if (options.template) {
      return fetcher(sessionId, options.template);
    }
    return sessionToken;
  };
};
var TokenVerificationError = class _TokenVerificationError extends Error {
  constructor({
    action,
    message,
    reason
  }) {
    super(message);
    Object.setPrototypeOf(this, _TokenVerificationError.prototype);
    this.reason = reason;
    this.message = message;
    this.action = action;
  }
  getFullMessage() {
    return `${[this.message, this.action].filter((m) => m).join(" ")} (reason=${this.reason}, token-carrier=${this.tokenCarrier})`;
  }
};
function loadInterstitialFromLocal(options) {
  var _a;
  if (options.frontendApi) {
    deprecated("frontendApi", "Use `publishableKey` instead.");
  }
  if (options.pkgVersion) {
    deprecated("pkgVersion", "Use `clerkJSVersion` instead.");
  }
  options.frontendApi = ((_a = parsePublishableKey(options.publishableKey)) == null ? void 0 : _a.frontendApi) || options.frontendApi || "";
  const domainOnlyInProd = !isDevOrStagingUrl(options.frontendApi) ? addClerkPrefix(options.domain) : "";
  const {
    debugData,
    frontendApi,
    pkgVersion,
    clerkJSUrl,
    clerkJSVersion,
    publishableKey,
    proxyUrl,
    isSatellite = false,
    domain,
    signInUrl
  } = options;
  return `
    <head>
        <meta charset="UTF-8" />
    </head>
    <body>
        <script>
            window.__clerk_frontend_api = '${frontendApi}';
            window.__clerk_debug = ${JSON.stringify(debugData || {})};
            ${proxyUrl ? `window.__clerk_proxy_url = '${proxyUrl}'` : ""}
            ${domain ? `window.__clerk_domain = '${domain}'` : ""}
            window.startClerk = async () => {
                function formRedirect(){
                    const form = '<form method="get" action="" name="redirect"></form>';
                    document.body.innerHTML = document.body.innerHTML + form;

                    const searchParams = new URLSearchParams(window.location.search);
                    for (let paramTuple of searchParams) {
                        const input = document.createElement("input");
                        input.type = "hidden";
                        input.name = paramTuple[0];
                        input.value = paramTuple[1];
                        document.forms.redirect.appendChild(input);
                    }
                    const url = new URL(window.location.origin + window.location.pathname + window.location.hash);
                    window.history.pushState({}, '', url);

                    document.forms.redirect.action = window.location.pathname + window.location.hash;
                    document.forms.redirect.submit();
                }

                const Clerk = window.Clerk;
                try {
                    await Clerk.load({
                        isSatellite: ${isSatellite},
                        isInterstitial: ${true},
                        signInUrl: ${signInUrl ? `'${signInUrl}'` : void 0}
                    });
                    if(Clerk.loaded){
                      if(window.location.href.indexOf("#") === -1){
                        window.location.href = window.location.href;
                      } else if (window.navigator.userAgent.toLowerCase().includes("firefox/")){
                          formRedirect();
                      } else {
                          window.location.reload();
                      }
                    }
                } catch (err) {
                    console.error('Clerk: ', err);
                }
            };
            (() => {
                const script = document.createElement('script');
                ${publishableKey ? `script.setAttribute('data-clerk-publishable-key', '${publishableKey}');` : `script.setAttribute('data-clerk-frontend-api', '${frontendApi}');`}

                ${domain ? `script.setAttribute('data-clerk-domain', '${domain}');` : ""}
                ${proxyUrl ? `script.setAttribute('data-clerk-proxy-url', '${proxyUrl}')` : ""};
                script.async = true;
                script.src = '${clerkJSUrl || getScriptUrl(proxyUrl || domainOnlyInProd || frontendApi, {
    pkgVersion,
    clerkJSVersion
  })}';
                script.crossOrigin = 'anonymous';
                script.addEventListener('load', startClerk);
                document.body.appendChild(script);
            })();
        <\/script>
    </body>
`;
}
async function loadInterstitialFromBAPI(options) {
  var _a;
  if (options.frontendApi) {
    deprecated("frontendApi", "Use `publishableKey` instead.");
  }
  if (options.pkgVersion) {
    deprecated("pkgVersion", "Use `clerkJSVersion` instead.");
  }
  options.frontendApi = ((_a = parsePublishableKey(options.publishableKey)) == null ? void 0 : _a.frontendApi) || options.frontendApi || "";
  const url = buildPublicInterstitialUrl(options);
  const response = await callWithRetry(
    () => runtime_default.fetch(buildPublicInterstitialUrl(options), {
      method: "GET",
      headers: {
        "Clerk-Backend-SDK": options.userAgent || USER_AGENT
      }
    })
  );
  if (!response.ok) {
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Error loading Clerk Interstitial from ${url} with code=${response.status}`,
      reason: "interstitial-remote-failed-to-load"
      /* RemoteInterstitialFailedToLoad */
    });
  }
  return response.text();
}
function buildPublicInterstitialUrl(options) {
  var _a;
  if (options.frontendApi) {
    deprecated("frontendApi", "Use `publishableKey` instead.");
  }
  options.frontendApi = ((_a = parsePublishableKey(options.publishableKey)) == null ? void 0 : _a.frontendApi) || options.frontendApi || "";
  const { apiUrl, frontendApi, pkgVersion, clerkJSVersion, publishableKey, proxyUrl, isSatellite, domain, signInUrl } = options;
  const url = new URL(apiUrl);
  url.pathname = joinPaths(url.pathname, API_VERSION, "/public/interstitial");
  url.searchParams.append("clerk_js_version", clerkJSVersion || getClerkJsMajorVersionOrTag(frontendApi, pkgVersion));
  if (publishableKey) {
    url.searchParams.append("publishable_key", publishableKey);
  } else {
    url.searchParams.append("frontend_api", frontendApi);
  }
  if (proxyUrl) {
    url.searchParams.append("proxy_url", proxyUrl);
  }
  if (isSatellite) {
    url.searchParams.append("is_satellite", "true");
  }
  url.searchParams.append("sign_in_url", signInUrl || "");
  if (!isDevOrStagingUrl(options.frontendApi)) {
    url.searchParams.append("use_domain_for_script", "true");
  }
  if (domain) {
    url.searchParams.append("domain", domain);
  }
  return url.href;
}
var getHeader = (req, key) => req.headers.get(key);
var getFirstValueFromHeader = (value) => value == null ? void 0 : value.split(",")[0];
var buildRequestUrl = (request, path) => {
  const initialUrl = new URL(request.url);
  const forwardedProto = getHeader(request, constants.Headers.ForwardedProto);
  const forwardedHost = getHeader(request, constants.Headers.ForwardedHost);
  const host = getHeader(request, constants.Headers.Host);
  const protocol = initialUrl.protocol;
  const base = buildOrigin({ protocol, forwardedProto, forwardedHost, host: host || initialUrl.host });
  return new URL(path || initialUrl.pathname, base);
};
var buildOrigin = ({ protocol, forwardedProto, forwardedHost, host }) => {
  const resolvedHost = getFirstValueFromHeader(forwardedHost) ?? host;
  const resolvedProtocol = getFirstValueFromHeader(forwardedProto) ?? (protocol == null ? void 0 : protocol.replace(/[:/]/, ""));
  if (!resolvedHost || !resolvedProtocol) {
    return "";
  }
  return `${resolvedProtocol}://${resolvedHost}`;
};
var createIsomorphicRequest = (cb) => {
  const req = cb(runtime_default.Request, runtime_default.Headers);
  const headersGeneratedURL = buildRequestUrl(req);
  return new runtime_default.Request(headersGeneratedURL, req);
};
var buildRequest2 = (req) => {
  if (!req) {
    return {};
  }
  const cookies = parseIsomorphicRequestCookies(req);
  const headers = getHeaderFromIsomorphicRequest(req);
  const searchParams = getSearchParamsFromIsomorphicRequest(req);
  return {
    cookies,
    headers,
    searchParams
  };
};
var decode = (str) => {
  if (!str) {
    return str;
  }
  return str.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
};
var parseIsomorphicRequestCookies = (req) => {
  var _a;
  const cookies = req.headers && ((_a = req.headers) == null ? void 0 : _a.get("cookie")) ? (0, import_cookie.parse)(req.headers.get("cookie")) : {};
  return (key) => {
    const value = cookies == null ? void 0 : cookies[key];
    if (value === void 0) {
      return void 0;
    }
    return decode(value);
  };
};
var getHeaderFromIsomorphicRequest = (req) => (key) => {
  var _a;
  return ((_a = req == null ? void 0 : req.headers) == null ? void 0 : _a.get(key)) || void 0;
};
var getSearchParamsFromIsomorphicRequest = (req) => {
  var _a;
  return (req == null ? void 0 : req.url) ? (_a = new URL(req.url)) == null ? void 0 : _a.searchParams : void 0;
};
var stripAuthorizationHeader = (authValue) => {
  return authValue == null ? void 0 : authValue.replace("Bearer ", "");
};
var AuthStatus = ((AuthStatus2) => {
  AuthStatus2["SignedIn"] = "signed-in";
  AuthStatus2["SignedOut"] = "signed-out";
  AuthStatus2["Interstitial"] = "interstitial";
  AuthStatus2["Unknown"] = "unknown";
  return AuthStatus2;
})(AuthStatus || {});
async function signedIn(options, sessionClaims) {
  const {
    apiKey,
    secretKey,
    apiUrl,
    apiVersion,
    cookieToken,
    frontendApi,
    proxyUrl,
    publishableKey,
    domain,
    isSatellite,
    headerToken,
    loadSession,
    loadUser,
    loadOrganization,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl
  } = options;
  const { sid: sessionId, org_id: orgId, sub: userId } = sessionClaims;
  const { sessions, users, organizations } = createBackendApiClient({
    apiKey,
    secretKey,
    apiUrl,
    apiVersion
  });
  const [sessionResp, userResp, organizationResp] = await Promise.all([
    loadSession ? sessions.getSession(sessionId) : Promise.resolve(void 0),
    loadUser ? users.getUser(userId) : Promise.resolve(void 0),
    loadOrganization && orgId ? organizations.getOrganization({ organizationId: orgId }) : Promise.resolve(void 0)
  ]);
  const session = sessionResp;
  const user = userResp;
  const organization = organizationResp;
  const authObject = signedInAuthObject(
    sessionClaims,
    {
      secretKey,
      apiKey,
      apiUrl,
      apiVersion,
      token: cookieToken || headerToken || "",
      session,
      user,
      organization
    },
    {
      ...options,
      status: "signed-in"
      /* SignedIn */
    }
  );
  return {
    status: "signed-in",
    reason: null,
    message: null,
    frontendApi,
    proxyUrl,
    publishableKey,
    domain,
    isSatellite,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: true,
    isInterstitial: false,
    isUnknown: false,
    toAuth: () => authObject
  };
}
function signedOut(options, reason, message = "") {
  const {
    frontendApi,
    publishableKey,
    proxyUrl,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl
  } = options;
  return {
    status: "signed-out",
    reason,
    message,
    frontendApi,
    proxyUrl,
    publishableKey,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: false,
    isInterstitial: false,
    isUnknown: false,
    toAuth: () => signedOutAuthObject({ ...options, status: "signed-out", reason, message })
  };
}
function interstitial(options, reason, message = "") {
  const {
    frontendApi,
    publishableKey,
    proxyUrl,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl
  } = options;
  return {
    status: "interstitial",
    reason,
    message,
    frontendApi,
    publishableKey,
    isSatellite,
    domain,
    proxyUrl,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: false,
    isInterstitial: true,
    isUnknown: false,
    toAuth: () => null
  };
}
function unknownState(options, reason, message = "") {
  const { frontendApi, publishableKey, isSatellite, domain, signInUrl, signUpUrl, afterSignInUrl, afterSignUpUrl } = options;
  return {
    status: "unknown",
    reason,
    message,
    frontendApi,
    publishableKey,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: false,
    isInterstitial: false,
    isUnknown: true,
    toAuth: () => null
  };
}
function checkCrossOrigin({
  originURL,
  host,
  forwardedHost,
  forwardedProto
}) {
  const finalURL = buildOrigin({ forwardedProto, forwardedHost, protocol: originURL.protocol, host });
  return finalURL && new URL(finalURL).origin !== originURL.origin;
}
var getErrorObjectByCode = (errors, code) => {
  if (!errors) {
    return null;
  }
  return errors.find((err) => err.code === code);
};
var base64url = {
  parse(string, opts) {
    return parse2(string, base64UrlEncoding, opts);
  },
  stringify(data, opts) {
    return stringify(data, base64UrlEncoding, opts);
  }
};
var base64UrlEncoding = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bits: 6
};
function parse2(string, encoding, opts = {}) {
  if (!encoding.codes) {
    encoding.codes = {};
    for (let i = 0; i < encoding.chars.length; ++i) {
      encoding.codes[encoding.chars[i]] = i;
    }
  }
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError("Invalid padding");
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError("Invalid padding");
    }
  }
  const out = new (opts.out ?? Uint8Array)(end * encoding.bits / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = encoding.codes[string[i]];
    if (value === void 0) {
      throw new SyntaxError("Invalid character " + string[i]);
    }
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= encoding.bits || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function stringify(data, encoding, opts = {}) {
  const { pad = true } = opts;
  const mask = (1 << encoding.bits) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | 255 & data[i];
    bits += 8;
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += "=";
    }
  }
  return out;
}
var algToHash = {
  RS256: "SHA-256",
  RS384: "SHA-384",
  RS512: "SHA-512"
};
var RSA_ALGORITHM_NAME = "RSASSA-PKCS1-v1_5";
var jwksAlgToCryptoAlg = {
  RS256: RSA_ALGORITHM_NAME,
  RS384: RSA_ALGORITHM_NAME,
  RS512: RSA_ALGORITHM_NAME
};
var algs = Object.keys(algToHash);
function getCryptoAlgorithm(algorithmName) {
  const hash = algToHash[algorithmName];
  const name = jwksAlgToCryptoAlg[algorithmName];
  if (!hash || !name) {
    throw new Error(`Unsupported algorithm ${algorithmName}, expected one of ${algs.join(",")}.`);
  }
  return {
    hash: { name: algToHash[algorithmName] },
    name: jwksAlgToCryptoAlg[algorithmName]
  };
}
var isArrayString = (s) => {
  return Array.isArray(s) && s.length > 0 && s.every((a) => typeof a === "string");
};
var assertAudienceClaim = (aud, audience) => {
  const audienceList = [audience].flat().filter((a) => !!a);
  const audList = [aud].flat().filter((a) => !!a);
  const shouldVerifyAudience = audienceList.length > 0 && audList.length > 0;
  if (!shouldVerifyAudience) {
    return;
  }
  if (typeof aud === "string") {
    if (!audienceList.includes(aud)) {
      throw new TokenVerificationError({
        action: "Make sure that this is a valid Clerk generate JWT.",
        reason: "token-verification-failed",
        message: `Invalid JWT audience claim (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(
          audienceList
        )}".`
      });
    }
  } else if (isArrayString(aud)) {
    if (!aud.some((a) => audienceList.includes(a))) {
      throw new TokenVerificationError({
        action: "Make sure that this is a valid Clerk generate JWT.",
        reason: "token-verification-failed",
        message: `Invalid JWT audience claim array (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(
          audienceList
        )}".`
      });
    }
  }
};
var assertHeaderType = (typ) => {
  if (typeof typ === "undefined") {
    return;
  }
  if (typ !== "JWT") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-invalid",
      message: `Invalid JWT type ${JSON.stringify(typ)}. Expected "JWT".`
    });
  }
};
var assertHeaderAlgorithm = (alg) => {
  if (!algs.includes(alg)) {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-invalid-algorithm",
      message: `Invalid JWT algorithm ${JSON.stringify(alg)}. Supported: ${algs}.`
    });
  }
};
var assertSubClaim = (sub) => {
  if (typeof sub !== "string") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Subject claim (sub) is required and must be a string. Received ${JSON.stringify(sub)}.`
    });
  }
};
var assertAuthorizedPartiesClaim = (azp, authorizedParties) => {
  if (!azp || !authorizedParties || authorizedParties.length === 0) {
    return;
  }
  if (!authorizedParties.includes(azp)) {
    throw new TokenVerificationError({
      reason: "token-invalid-authorized-parties",
      message: `Invalid JWT Authorized party claim (azp) ${JSON.stringify(azp)}. Expected "${authorizedParties}".`
    });
  }
};
var assertIssuerClaim = (iss, issuer) => {
  if (typeof issuer === "function" && !issuer(iss)) {
    throw new TokenVerificationError({
      reason: "token-invalid-issuer",
      message: "Failed JWT issuer resolver. Make sure that the resolver returns a truthy value."
    });
  } else if (typeof issuer === "string" && iss && iss !== issuer) {
    throw new TokenVerificationError({
      reason: "token-invalid-issuer",
      message: `Invalid JWT issuer claim (iss) ${JSON.stringify(iss)}. Expected "${issuer}".`
    });
  }
};
var assertExpirationClaim = (exp, clockSkewInMs) => {
  if (typeof exp !== "number") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Invalid JWT expiry date claim (exp) ${JSON.stringify(exp)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const expiryDate = /* @__PURE__ */ new Date(0);
  expiryDate.setUTCSeconds(exp);
  const expired = expiryDate.getTime() <= currentDate.getTime() - clockSkewInMs;
  if (expired) {
    throw new TokenVerificationError({
      reason: "token-expired",
      message: `JWT is expired. Expiry date: ${expiryDate.toUTCString()}, Current date: ${currentDate.toUTCString()}.`
    });
  }
};
var assertActivationClaim = (nbf, clockSkewInMs) => {
  if (typeof nbf === "undefined") {
    return;
  }
  if (typeof nbf !== "number") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Invalid JWT not before date claim (nbf) ${JSON.stringify(nbf)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const notBeforeDate = /* @__PURE__ */ new Date(0);
  notBeforeDate.setUTCSeconds(nbf);
  const early = notBeforeDate.getTime() > currentDate.getTime() + clockSkewInMs;
  if (early) {
    throw new TokenVerificationError({
      reason: "token-not-active-yet",
      message: `JWT cannot be used prior to not before date claim (nbf). Not before date: ${notBeforeDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`
    });
  }
};
var assertIssuedAtClaim = (iat, clockSkewInMs) => {
  if (typeof iat === "undefined") {
    return;
  }
  if (typeof iat !== "number") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Invalid JWT issued at date claim (iat) ${JSON.stringify(iat)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const issuedAtDate = /* @__PURE__ */ new Date(0);
  issuedAtDate.setUTCSeconds(iat);
  const postIssued = issuedAtDate.getTime() > currentDate.getTime() + clockSkewInMs;
  if (postIssued) {
    throw new TokenVerificationError({
      reason: "token-not-active-yet",
      message: `JWT issued at date claim (iat) is in the future. Issued at date: ${issuedAtDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`
    });
  }
};
function pemToBuffer(secret) {
  const trimmed = secret.replace(/-----BEGIN.*?-----/g, "").replace(/-----END.*?-----/g, "").replace(/\s/g, "");
  const decoded = isomorphicAtob(trimmed);
  const buffer = new ArrayBuffer(decoded.length);
  const bufView = new Uint8Array(buffer);
  for (let i = 0, strLen = decoded.length; i < strLen; i++) {
    bufView[i] = decoded.charCodeAt(i);
  }
  return bufView;
}
function importKey(key, algorithm, keyUsage) {
  if (typeof key === "object") {
    return runtime_default.crypto.subtle.importKey("jwk", key, algorithm, false, [keyUsage]);
  }
  const keyData = pemToBuffer(key);
  const format = keyUsage === "sign" ? "pkcs8" : "spki";
  return runtime_default.crypto.subtle.importKey(format, keyData, algorithm, false, [keyUsage]);
}
var DEFAULT_CLOCK_SKEW_IN_SECONDS = 5 * 1e3;
async function hasValidSignature(jwt, key) {
  const { header, signature, raw } = jwt;
  const encoder = new TextEncoder();
  const data = encoder.encode([raw.header, raw.payload].join("."));
  const algorithm = getCryptoAlgorithm(header.alg);
  const cryptoKey = await importKey(key, algorithm, "verify");
  return runtime_default.crypto.subtle.verify(algorithm.name, cryptoKey, signature, data);
}
function decodeJwt(token) {
  const tokenParts = (token || "").toString().split(".");
  if (tokenParts.length !== 3) {
    throw new TokenVerificationError({
      reason: "token-invalid",
      message: `Invalid JWT form. A JWT consists of three parts separated by dots.`
    });
  }
  const [rawHeader, rawPayload, rawSignature] = tokenParts;
  const decoder = new TextDecoder();
  const header = JSON.parse(decoder.decode(base64url.parse(rawHeader, { loose: true })));
  const payload = JSON.parse(decoder.decode(base64url.parse(rawPayload, { loose: true })));
  const signature = base64url.parse(rawSignature, { loose: true });
  deprecatedObjectProperty(
    payload,
    "orgs",
    'Add orgs to your session token using the "user.organizations" shortcode in JWT Templates instead.',
    "decodeJwt:orgs"
  );
  return {
    header,
    payload,
    signature,
    raw: {
      header: rawHeader,
      payload: rawPayload,
      signature: rawSignature,
      text: token
    }
  };
}
async function verifyJwt(token, { audience, authorizedParties, clockSkewInSeconds, clockSkewInMs, issuer, key }) {
  if (clockSkewInSeconds) {
    deprecated("clockSkewInSeconds", "Use `clockSkewInMs` instead.");
  }
  const clockSkew = clockSkewInMs || clockSkewInSeconds || DEFAULT_CLOCK_SKEW_IN_SECONDS;
  const decoded = decodeJwt(token);
  const { header, payload } = decoded;
  const { typ, alg } = header;
  assertHeaderType(typ);
  assertHeaderAlgorithm(alg);
  const { azp, sub, aud, iss, iat, exp, nbf } = payload;
  assertSubClaim(sub);
  assertAudienceClaim([aud], [audience]);
  assertAuthorizedPartiesClaim(azp, authorizedParties);
  assertIssuerClaim(iss, issuer);
  assertExpirationClaim(exp, clockSkew);
  assertActivationClaim(nbf, clockSkew);
  assertIssuedAtClaim(iat, clockSkew);
  let signatureValid;
  try {
    signatureValid = await hasValidSignature(decoded, key);
  } catch (err) {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Error verifying JWT signature. ${err}`
    });
  }
  if (!signatureValid) {
    throw new TokenVerificationError({
      reason: "token-invalid-signature",
      message: "JWT signature is invalid."
    });
  }
  return payload;
}
function encodeJwtData(value) {
  const stringified = JSON.stringify(value);
  const encoder = new TextEncoder();
  const encoded = encoder.encode(stringified);
  return base64url.stringify(encoded, { pad: false });
}
async function signJwt(payload, key, options) {
  if (!options.algorithm) {
    throw new Error("No algorithm specified");
  }
  const encoder = new TextEncoder();
  const algorithm = getCryptoAlgorithm(options.algorithm);
  if (!algorithm) {
    throw new Error(`Unsupported algorithm ${options.algorithm}`);
  }
  const cryptoKey = await importKey(key, algorithm, "sign");
  const header = options.header || { typ: "JWT" };
  header.alg = options.algorithm;
  payload.iat = Math.floor(Date.now() / 1e3);
  const encodedHeader = encodeJwtData(header);
  const encodedPayload = encodeJwtData(payload);
  const firstPart = `${encodedHeader}.${encodedPayload}`;
  const signature = await runtime_default.crypto.subtle.sign(algorithm, cryptoKey, encoder.encode(firstPart));
  return `${firstPart}.${base64url.stringify(new Uint8Array(signature), { pad: false })}`;
}
var cache = {};
var lastUpdatedAt = 0;
function getFromCache(kid) {
  return cache[kid];
}
function getCacheValues() {
  return Object.values(cache);
}
function setInCache(jwk, jwksCacheTtlInMs = 1e3 * 60 * 60) {
  cache[jwk.kid] = jwk;
  lastUpdatedAt = Date.now();
  if (jwksCacheTtlInMs >= 0) {
    setTimeout(() => {
      if (jwk) {
        delete cache[jwk.kid];
      } else {
        cache = {};
      }
    }, jwksCacheTtlInMs);
  }
}
var LocalJwkKid = "local";
var PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
var PEM_TRAILER = "-----END PUBLIC KEY-----";
var RSA_PREFIX = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA";
var RSA_SUFFIX = "IDAQAB";
function loadClerkJWKFromLocal(localKey) {
  if (!getFromCache(LocalJwkKid)) {
    if (!localKey) {
      throw new TokenVerificationError({
        action: "Set the CLERK_JWT_KEY environment variable.",
        message: "Missing local JWK.",
        reason: "jwk-local-missing"
        /* LocalJWKMissing */
      });
    }
    const modulus = localKey.replace(/(\r\n|\n|\r)/gm, "").replace(PEM_HEADER, "").replace(PEM_TRAILER, "").replace(RSA_PREFIX, "").replace(RSA_SUFFIX, "").replace(/\+/g, "-").replace(/\//g, "_");
    setInCache(
      {
        kid: "local",
        kty: "RSA",
        alg: "RS256",
        n: modulus,
        e: "AQAB"
      },
      -1
      // local key never expires in cache
    );
  }
  return getFromCache(LocalJwkKid);
}
async function loadClerkJWKFromRemote({
  apiKey,
  secretKey,
  apiUrl = API_URL,
  apiVersion = API_VERSION,
  issuer,
  kid,
  jwksCacheTtlInMs = 1e3 * 60 * 60,
  // 1 hour,
  skipJwksCache
}) {
  const shouldRefreshCache = !getFromCache(kid) && reachedMaxCacheUpdatedAt();
  if (skipJwksCache || shouldRefreshCache) {
    let fetcher;
    const key = secretKey || apiKey;
    if (key) {
      fetcher = () => fetchJWKSFromBAPI(apiUrl, key, apiVersion);
    } else if (issuer) {
      fetcher = () => fetchJWKSFromFAPI(issuer);
    } else {
      throw new TokenVerificationError({
        action: "Contact support@clerk.com",
        message: "Failed to load JWKS from Clerk Backend or Frontend API.",
        reason: "jwk-remote-failed-to-load"
        /* RemoteJWKFailedToLoad */
      });
    }
    const { keys } = await callWithRetry(fetcher);
    if (!keys || !keys.length) {
      throw new TokenVerificationError({
        action: "Contact support@clerk.com",
        message: "The JWKS endpoint did not contain any signing keys. Contact support@clerk.com.",
        reason: "jwk-remote-failed-to-load"
        /* RemoteJWKFailedToLoad */
      });
    }
    keys.forEach((key2) => setInCache(key2, jwksCacheTtlInMs));
  }
  const jwk = getFromCache(kid);
  if (!jwk) {
    const cacheValues = getCacheValues();
    const jwkKeys = cacheValues.map((jwk2) => jwk2.kid).join(", ");
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Unable to find a signing key in JWKS that matches the kid='${kid}' of the provided session token. Please make sure that the __session cookie or the HTTP authorization header contain a Clerk-generated session JWT.${jwkKeys ? ` The following kid are available: ${jwkKeys}` : ""}`,
      reason: "jwk-remote-missing"
      /* RemoteJWKMissing */
    });
  }
  return jwk;
}
async function fetchJWKSFromFAPI(issuer) {
  const url = new URL(issuer);
  url.pathname = joinPaths(url.pathname, ".well-known/jwks.json");
  const response = await runtime_default.fetch(url.href);
  if (!response.ok) {
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Error loading Clerk JWKS from ${url.href} with code=${response.status}`,
      reason: "jwk-remote-failed-to-load"
      /* RemoteJWKFailedToLoad */
    });
  }
  return response.json();
}
async function fetchJWKSFromBAPI(apiUrl, key, apiVersion) {
  if (!key) {
    throw new TokenVerificationError({
      action: "Set the CLERK_SECRET_KEY or CLERK_API_KEY environment variable.",
      message: "Missing Clerk Secret Key or API Key. Go to https://dashboard.clerk.com and get your key for your instance.",
      reason: "jwk-remote-failed-to-load"
      /* RemoteJWKFailedToLoad */
    });
  }
  const url = new URL(apiUrl);
  url.pathname = joinPaths(url.pathname, apiVersion, "/jwks");
  const response = await runtime_default.fetch(url.href, {
    headers: {
      Authorization: `Bearer ${key}`,
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    const json = await response.json();
    const invalidSecretKeyError = getErrorObjectByCode(
      json == null ? void 0 : json.errors,
      "clerk_key_invalid"
      /* InvalidSecretKey */
    );
    if (invalidSecretKeyError) {
      const reason = "secret-key-invalid";
      throw new TokenVerificationError({
        action: "Contact support@clerk.com",
        message: invalidSecretKeyError.message,
        reason
      });
    }
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Error loading Clerk JWKS from ${url.href} with code=${response.status}`,
      reason: "jwk-remote-failed-to-load"
      /* RemoteJWKFailedToLoad */
    });
  }
  return response.json();
}
function reachedMaxCacheUpdatedAt() {
  return Date.now() - lastUpdatedAt >= MAX_CACHE_LAST_UPDATED_AT_SECONDS * 1e3;
}
async function verifyToken(token, options) {
  const {
    apiKey,
    secretKey,
    apiUrl,
    apiVersion,
    audience,
    authorizedParties,
    clockSkewInSeconds,
    clockSkewInMs,
    issuer,
    jwksCacheTtlInMs,
    jwtKey,
    skipJwksCache
  } = options;
  if (options.apiKey) {
    deprecated("apiKey", "Use `secretKey` instead.");
  }
  const { header } = decodeJwt(token);
  const { kid } = header;
  let key;
  if (jwtKey) {
    key = loadClerkJWKFromLocal(jwtKey);
  } else if (typeof issuer === "string") {
    key = await loadClerkJWKFromRemote({ issuer, kid, jwksCacheTtlInMs, skipJwksCache });
  } else if (apiKey || secretKey) {
    key = await loadClerkJWKFromRemote({ apiKey, secretKey, apiUrl, apiVersion, kid, jwksCacheTtlInMs, skipJwksCache });
  } else {
    throw new TokenVerificationError({
      action: "Set the CLERK_JWT_KEY environment variable.",
      message: "Failed to resolve JWK during verification.",
      reason: "jwk-failed-to-resolve"
      /* JWKFailedToResolve */
    });
  }
  return await verifyJwt(token, {
    audience,
    authorizedParties,
    clockSkewInSeconds,
    clockSkewInMs,
    key,
    issuer
  });
}
var shouldRedirectToSatelliteUrl = (qp) => !!(qp == null ? void 0 : qp.get("__clerk_satellite_url"));
var hasJustSynced = (qp) => (qp == null ? void 0 : qp.get("__clerk_synced")) === "true";
var VALID_USER_AGENTS = /^Mozilla\/|(Amazon CloudFront)/;
var isBrowser = (userAgent) => VALID_USER_AGENTS.test(userAgent || "");
var nonBrowserRequestInDevRule = (options) => {
  const { apiKey, secretKey, userAgent } = options;
  const key = secretKey || apiKey || "";
  if (isDevelopmentFromApiKey(key) && !isBrowser(userAgent)) {
    return signedOut(
      options,
      "header-missing-non-browser"
      /* HeaderMissingNonBrowser */
    );
  }
  return void 0;
};
var crossOriginRequestWithoutHeader = (options) => {
  const { origin, host, forwardedHost, forwardedProto } = options;
  const isCrossOrigin = origin && checkCrossOrigin({
    originURL: new URL(origin),
    host,
    forwardedHost,
    forwardedProto
  });
  if (isCrossOrigin) {
    return signedOut(
      options,
      "header-missing-cors"
      /* HeaderMissingCORS */
    );
  }
  return void 0;
};
var isPrimaryInDevAndRedirectsToSatellite = (options) => {
  const { apiKey, secretKey, isSatellite, searchParams } = options;
  const key = secretKey || apiKey || "";
  const isDev = isDevelopmentFromApiKey(key);
  if (isDev && !isSatellite && shouldRedirectToSatelliteUrl(searchParams)) {
    return interstitial(
      options,
      "primary-responds-to-syncing"
      /* PrimaryRespondsToSyncing */
    );
  }
  return void 0;
};
var potentialFirstLoadInDevWhenUATMissing = (options) => {
  const { apiKey, secretKey, clientUat } = options;
  const key = secretKey || apiKey || "";
  const res = isDevelopmentFromApiKey(key);
  if (res && !clientUat) {
    return interstitial(
      options,
      "uat-missing"
      /* CookieUATMissing */
    );
  }
  return void 0;
};
var potentialRequestAfterSignInOrOutFromClerkHostedUiInDev = (options) => {
  const { apiKey, secretKey, referrer, host, forwardedHost, forwardedProto } = options;
  const crossOriginReferrer = referrer && checkCrossOrigin({ originURL: new URL(referrer), host, forwardedHost, forwardedProto });
  const key = secretKey || apiKey || "";
  if (isDevelopmentFromApiKey(key) && crossOriginReferrer) {
    return interstitial(
      options,
      "cross-origin-referrer"
      /* CrossOriginReferrer */
    );
  }
  return void 0;
};
var potentialFirstRequestOnProductionEnvironment = (options) => {
  const { apiKey, secretKey, clientUat, cookieToken } = options;
  const key = secretKey || apiKey || "";
  if (isProductionFromApiKey(key) && !clientUat && !cookieToken) {
    return signedOut(
      options,
      "cookie-and-uat-missing"
      /* CookieAndUATMissing */
    );
  }
  return void 0;
};
var isNormalSignedOutState = (options) => {
  const { clientUat } = options;
  if (clientUat === "0") {
    return signedOut(
      options,
      "standard-signed-out"
      /* StandardSignedOut */
    );
  }
  return void 0;
};
var hasPositiveClientUatButCookieIsMissing = (options) => {
  const { clientUat, cookieToken } = options;
  if (clientUat && Number.parseInt(clientUat) > 0 && !cookieToken) {
    return interstitial(
      options,
      "cookie-missing"
      /* CookieMissing */
    );
  }
  return void 0;
};
var hasValidHeaderToken = async (options) => {
  const { headerToken } = options;
  const sessionClaims = await verifyRequestState(options, headerToken);
  return await signedIn(options, sessionClaims);
};
var hasValidCookieToken = async (options) => {
  const { cookieToken, clientUat } = options;
  const sessionClaims = await verifyRequestState(options, cookieToken);
  const state = await signedIn(options, sessionClaims);
  const jwt = state.toAuth().sessionClaims;
  const cookieTokenIsOutdated = jwt.iat < Number.parseInt(clientUat);
  if (!clientUat || cookieTokenIsOutdated) {
    return interstitial(
      options,
      "cookie-outdated"
      /* CookieOutDated */
    );
  }
  return state;
};
async function runInterstitialRules(opts, rules) {
  for (const rule of rules) {
    const res = await rule(opts);
    if (res) {
      return res;
    }
  }
  return signedOut(
    opts,
    "unexpected-error"
    /* UnexpectedError */
  );
}
async function verifyRequestState(options, token) {
  const { isSatellite, proxyUrl } = options;
  let issuer;
  if (isSatellite) {
    issuer = null;
  } else if (proxyUrl) {
    issuer = proxyUrl;
  } else {
    issuer = (iss) => iss.startsWith("https://clerk.") || iss.includes(".clerk.accounts");
  }
  return verifyToken(token, { ...options, issuer });
}
var isSatelliteAndNeedsSyncing = (options) => {
  const { clientUat, isSatellite, searchParams, userAgent } = options;
  const isSignedOut = !clientUat || clientUat === "0";
  if (isSatellite && isSignedOut && !isBrowser(userAgent)) {
    return signedOut(
      options,
      "satellite-needs-syncing"
      /* SatelliteCookieNeedsSyncing */
    );
  }
  if (isSatellite && isSignedOut && !hasJustSynced(searchParams)) {
    return interstitial(
      options,
      "satellite-needs-syncing"
      /* SatelliteCookieNeedsSyncing */
    );
  }
  return void 0;
};
function assertSignInUrlExists(signInUrl, key) {
  if (!signInUrl && isDevelopmentFromApiKey(key)) {
    throw new Error(`Missing signInUrl. Pass a signInUrl for dev instances if an app is satellite`);
  }
}
function assertProxyUrlOrDomain(proxyUrlOrDomain) {
  if (!proxyUrlOrDomain) {
    throw new Error(`Missing domain and proxyUrl. A satellite application needs to specify a domain or a proxyUrl`);
  }
}
function assertSignInUrlFormatAndOrigin(_signInUrl, origin) {
  let signInUrl;
  try {
    signInUrl = new URL(_signInUrl);
  } catch {
    throw new Error(`The signInUrl needs to have a absolute url format.`);
  }
  if (signInUrl.origin === origin) {
    throw new Error(`The signInUrl needs to be on a different origin than your satellite application.`);
  }
}
async function authenticateRequest(options) {
  var _a;
  const { cookies, headers, searchParams } = buildRequest2(options == null ? void 0 : options.request);
  if (options.frontendApi) {
    deprecated("frontendApi", "Use `publishableKey` instead.");
  }
  if (options.apiKey) {
    deprecated("apiKey", "Use `secretKey` instead.");
  }
  options = {
    ...options,
    ...loadOptionsFromHeaders(options, headers),
    frontendApi: ((_a = parsePublishableKey(options.publishableKey)) == null ? void 0 : _a.frontendApi) || options.frontendApi,
    apiUrl: options.apiUrl || API_URL,
    apiVersion: options.apiVersion || API_VERSION,
    cookieToken: options.cookieToken || (cookies == null ? void 0 : cookies(constants.Cookies.Session)),
    clientUat: options.clientUat || (cookies == null ? void 0 : cookies(constants.Cookies.ClientUat)),
    searchParams: options.searchParams || searchParams || void 0
  };
  assertValidSecretKey(options.secretKey || options.apiKey);
  if (options.isSatellite) {
    assertSignInUrlExists(options.signInUrl, options.secretKey || options.apiKey);
    if (options.signInUrl && options.origin) {
      assertSignInUrlFormatAndOrigin(options.signInUrl, options.origin);
    }
    assertProxyUrlOrDomain(options.proxyUrl || options.domain);
  }
  async function authenticateRequestWithTokenInHeader() {
    try {
      const state = await runInterstitialRules(options, [hasValidHeaderToken]);
      return state;
    } catch (err) {
      return handleError(err, "header");
    }
  }
  async function authenticateRequestWithTokenInCookie() {
    try {
      const state = await runInterstitialRules(options, [
        crossOriginRequestWithoutHeader,
        nonBrowserRequestInDevRule,
        isSatelliteAndNeedsSyncing,
        isPrimaryInDevAndRedirectsToSatellite,
        potentialFirstRequestOnProductionEnvironment,
        potentialFirstLoadInDevWhenUATMissing,
        potentialRequestAfterSignInOrOutFromClerkHostedUiInDev,
        hasPositiveClientUatButCookieIsMissing,
        isNormalSignedOutState,
        hasValidCookieToken
      ]);
      return state;
    } catch (err) {
      return handleError(err, "cookie");
    }
  }
  function handleError(err, tokenCarrier) {
    if (err instanceof TokenVerificationError) {
      err.tokenCarrier = tokenCarrier;
      const reasonToReturnInterstitial = [
        "token-expired",
        "token-not-active-yet"
        /* TokenNotActiveYet */
      ].includes(err.reason);
      if (reasonToReturnInterstitial) {
        if (tokenCarrier === "header") {
          return unknownState(options, err.reason, err.getFullMessage());
        }
        return interstitial(options, err.reason, err.getFullMessage());
      }
      return signedOut(options, err.reason, err.getFullMessage());
    }
    return signedOut(options, "unexpected-error", err.message);
  }
  if (options.headerToken) {
    return authenticateRequestWithTokenInHeader();
  }
  return authenticateRequestWithTokenInCookie();
}
var debugRequestState = (params) => {
  const { frontendApi, isSignedIn, proxyUrl, isInterstitial, reason, message, publishableKey, isSatellite, domain } = params;
  return { frontendApi, isSignedIn, proxyUrl, isInterstitial, reason, message, publishableKey, isSatellite, domain };
};
var loadOptionsFromHeaders = (options, headers) => {
  if (!headers) {
    return {};
  }
  return {
    headerToken: stripAuthorizationHeader(options.headerToken || headers(constants.Headers.Authorization)),
    origin: options.origin || headers(constants.Headers.Origin),
    host: options.host || headers(constants.Headers.Host),
    forwardedHost: options.forwardedHost || headers(constants.Headers.ForwardedHost),
    forwardedPort: options.forwardedPort || headers(constants.Headers.ForwardedPort),
    forwardedProto: options.forwardedProto || headers(constants.Headers.CloudFrontForwardedProto) || headers(constants.Headers.ForwardedProto),
    referrer: options.referrer || headers(constants.Headers.Referrer),
    userAgent: options.userAgent || headers(constants.Headers.UserAgent)
  };
};
function createAuthenticateRequest(params) {
  const { apiClient } = params;
  const {
    apiKey: buildtimeApiKey = "",
    secretKey: buildtimeSecretKey = "",
    jwtKey: buildtimeJwtKey = "",
    apiUrl = API_URL,
    apiVersion = API_VERSION,
    frontendApi: buildtimeFrontendApi = "",
    proxyUrl: buildProxyUrl = "",
    publishableKey: buildtimePublishableKey = "",
    isSatellite: buildtimeIsSatellite = false,
    domain: buildtimeDomain = "",
    audience: buildtimeAudience = "",
    userAgent: buildUserAgent
  } = params.options;
  const authenticateRequest2 = ({
    apiKey: runtimeApiKey,
    secretKey: runtimeSecretKey,
    audience: runtimeAudience,
    frontendApi: runtimeFrontendApi,
    proxyUrl: runtimeProxyUrl,
    publishableKey: runtimePublishableKey,
    jwtKey: runtimeJwtKey,
    isSatellite: runtimeIsSatellite,
    domain: runtimeDomain,
    searchParams,
    ...rest
  }) => {
    return authenticateRequest({
      ...rest,
      apiKey: runtimeApiKey || buildtimeApiKey,
      secretKey: runtimeSecretKey || buildtimeSecretKey,
      audience: runtimeAudience || buildtimeAudience,
      apiUrl,
      apiVersion,
      frontendApi: runtimeFrontendApi || buildtimeFrontendApi,
      proxyUrl: runtimeProxyUrl || buildProxyUrl,
      publishableKey: runtimePublishableKey || buildtimePublishableKey,
      isSatellite: runtimeIsSatellite || buildtimeIsSatellite,
      domain: runtimeDomain || buildtimeDomain,
      jwtKey: runtimeJwtKey || buildtimeJwtKey,
      searchParams
    });
  };
  const localInterstitial = ({
    frontendApi: runtimeFrontendApi,
    publishableKey: runtimePublishableKey,
    proxyUrl: runtimeProxyUrl,
    isSatellite: runtimeIsSatellite,
    domain: runtimeDomain,
    ...rest
  }) => loadInterstitialFromLocal({
    ...rest,
    frontendApi: runtimeFrontendApi || buildtimeFrontendApi,
    proxyUrl: runtimeProxyUrl || buildProxyUrl,
    publishableKey: runtimePublishableKey || buildtimePublishableKey,
    isSatellite: runtimeIsSatellite || buildtimeIsSatellite,
    domain: runtimeDomain || buildtimeDomain
  });
  const remotePublicInterstitial = ({
    frontendApi: runtimeFrontendApi,
    publishableKey: runtimePublishableKey,
    proxyUrl: runtimeProxyUrl,
    isSatellite: runtimeIsSatellite,
    domain: runtimeDomain,
    userAgent: runtimeUserAgent,
    ...rest
  }) => {
    return loadInterstitialFromBAPI({
      ...rest,
      apiUrl,
      frontendApi: runtimeFrontendApi || buildtimeFrontendApi,
      publishableKey: runtimePublishableKey || buildtimePublishableKey,
      proxyUrl: runtimeProxyUrl || buildProxyUrl,
      isSatellite: runtimeIsSatellite || buildtimeIsSatellite,
      domain: runtimeDomain || buildtimeDomain,
      userAgent: runtimeUserAgent || buildUserAgent
    });
  };
  const remotePublicInterstitialUrl = buildPublicInterstitialUrl;
  const remotePrivateInterstitial = () => apiClient.interstitial.getInterstitial();
  return {
    authenticateRequest: authenticateRequest2,
    localInterstitial,
    remotePublicInterstitial,
    remotePrivateInterstitial,
    remotePublicInterstitialUrl,
    debugRequestState
  };
}
var buildUrl = (targetUrl, redirectUrl) => {
  let url;
  if (!targetUrl.startsWith("http")) {
    if (!redirectUrl || !redirectUrl.startsWith("http")) {
      throw new Error("destination url or return back url should be an absolute path url!");
    }
    const baseURL = new URL(redirectUrl);
    url = new URL(targetUrl, baseURL.origin);
  } else {
    url = new URL(targetUrl);
  }
  if (redirectUrl) {
    url.searchParams.set("redirect_url", redirectUrl);
  }
  return url.toString();
};
function redirect({ redirectAdapter, signUpUrl, signInUrl, frontendApi, publishableKey }) {
  var _a;
  if (!frontendApi) {
    frontendApi = (_a = parsePublishableKey(publishableKey)) == null ? void 0 : _a.frontendApi;
  } else {
    deprecated("frontendApi", "Use `publishableKey` instead.");
  }
  const accountsBaseUrl = buildAccountsBaseUrl(frontendApi);
  const redirectToSignUp = ({ returnBackUrl } = {}) => {
    if (!signUpUrl && !accountsBaseUrl) {
      errorThrower.throwMissingPublishableKeyError();
    }
    const accountsSignUpUrl = `${accountsBaseUrl}/sign-up`;
    return redirectAdapter(buildUrl(signUpUrl || accountsSignUpUrl, returnBackUrl));
  };
  const redirectToSignIn = ({ returnBackUrl } = {}) => {
    if (!signInUrl && !accountsBaseUrl) {
      errorThrower.throwMissingPublishableKeyError();
    }
    const accountsSignInUrl = `${accountsBaseUrl}/sign-in`;
    return redirectAdapter(buildUrl(signInUrl || accountsSignInUrl, returnBackUrl));
  };
  return { redirectToSignUp, redirectToSignIn };
}
function buildAccountsBaseUrl(frontendApi) {
  if (!frontendApi) {
    return "";
  }
  const accountsBaseUrl = frontendApi.replace(/(clerk\.accountsstage\.)/, "accountsstage.").replace(/(clerk\.accounts\.|clerk\.)/, "accounts.");
  return `https://${accountsBaseUrl}`;
}
function Clerk(options) {
  const opts = { ...options };
  const apiClient = createBackendApiClient(opts);
  const requestState = createAuthenticateRequest({ options: opts, apiClient });
  const clerkInstance = {
    ...apiClient,
    ...requestState,
    /**
     * @deprecated This prop has been deprecated and will be removed in the next major release.
     */
    __unstable_options: opts
  };
  deprecatedObjectProperty(
    clerkInstance,
    "__unstable_options",
    "Use `createClerkClient({...})` to create a new clerk instance instead."
  );
  return clerkInstance;
}
export {
  AllowlistIdentifier,
  AuthStatus,
  Clerk,
  Client,
  DeletedObject,
  Email,
  EmailAddress,
  ExternalAccount,
  IdentificationLink,
  Invitation,
  OauthAccessToken,
  ObjectType,
  Organization,
  OrganizationInvitation,
  OrganizationMembership,
  OrganizationMembershipPublicUserData,
  PhoneNumber,
  RedirectUrl,
  SMSMessage,
  Session,
  SignInToken,
  Token,
  User,
  Verification,
  buildRequestUrl,
  constants,
  createAuthenticateRequest,
  createIsomorphicRequest,
  debugRequestState,
  decodeJwt,
  deserialize,
  hasValidSignature,
  loadInterstitialFromLocal,
  makeAuthObjectSerializable,
  prunePrivateMetadata,
  redirect,
  sanitizeAuthObject,
  signJwt,
  signedInAuthObject,
  signedOutAuthObject,
  verifyJwt,
  verifyToken
};
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=@clerk_backend.js.map
